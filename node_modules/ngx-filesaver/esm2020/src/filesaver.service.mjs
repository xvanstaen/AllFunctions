import { Injectable } from '@angular/core';
import { saveAs } from 'file-saver';
import * as i0 from "@angular/core";
/** Check the `Blob` existance only once. */
let isFileSaverSupported;
try {
    isFileSaverSupported = !!new Blob();
}
catch {
    isFileSaverSupported = false;
}
export class FileSaverService {
    get isFileSaverSupported() {
        return isFileSaverSupported;
    }
    genType(fileName) {
        if (!fileName || fileName.lastIndexOf('.') === -1) {
            return 'text/plain';
        }
        const type = fileName.substring(fileName.lastIndexOf('.') + 1);
        switch (type) {
            case 'txt':
                return 'text/plain';
            case 'xml':
            case 'html':
                return `text/${type}`;
            case 'json':
                return 'octet/stream';
            default:
                return `application/${type}`;
        }
    }
    save(blob, fileName, filtType, option) {
        if (!blob) {
            throw new Error('Data argument should be a blob instance');
        }
        const file = new Blob([blob], { type: filtType || blob.type || this.genType(fileName) });
        saveAs(file, decodeURI(fileName || 'download'), option);
    }
    saveText(txt, fileName, option) {
        const blob = new Blob([txt]);
        this.save(blob, fileName, undefined, option);
    }
}
FileSaverService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.1", ngImport: i0, type: FileSaverService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FileSaverService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.1", ngImport: i0, type: FileSaverService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.1", ngImport: i0, type: FileSaverService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXNhdmVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvc3JjL2ZpbGVzYXZlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBb0IsTUFBTSxZQUFZLENBQUM7O0FBRXRELDRDQUE0QztBQUM1QyxJQUFJLG9CQUE2QixDQUFDO0FBQ2xDLElBQUk7SUFDRixvQkFBb0IsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztDQUNyQztBQUFDLE1BQU07SUFDTixvQkFBb0IsR0FBRyxLQUFLLENBQUM7Q0FDOUI7QUFHRCxNQUFNLE9BQU8sZ0JBQWdCO0lBQzNCLElBQUksb0JBQW9CO1FBQ3RCLE9BQU8sb0JBQW9CLENBQUM7SUFDOUIsQ0FBQztJQUVELE9BQU8sQ0FBQyxRQUFpQjtRQUN2QixJQUFJLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDakQsT0FBTyxZQUFZLENBQUM7U0FDckI7UUFDRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0QsUUFBUSxJQUFJLEVBQUU7WUFDWixLQUFLLEtBQUs7Z0JBQ1IsT0FBTyxZQUFZLENBQUM7WUFDdEIsS0FBSyxLQUFLLENBQUM7WUFDWCxLQUFLLE1BQU07Z0JBQ1QsT0FBTyxRQUFRLElBQUksRUFBRSxDQUFDO1lBQ3hCLEtBQUssTUFBTTtnQkFDVCxPQUFPLGNBQWMsQ0FBQztZQUN4QjtnQkFDRSxPQUFPLGVBQWUsSUFBSSxFQUFFLENBQUM7U0FDaEM7SUFDSCxDQUFDO0lBRUQsSUFBSSxDQUFDLElBQWlCLEVBQUUsUUFBaUIsRUFBRSxRQUFpQixFQUFFLE1BQXlCO1FBQ3JGLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pGLE1BQU0sQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLFFBQVEsSUFBSSxVQUFVLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQsUUFBUSxDQUFDLEdBQVcsRUFBRSxRQUFpQixFQUFFLE1BQXlCO1FBQ2hFLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQy9DLENBQUM7OzZHQW5DVSxnQkFBZ0I7aUhBQWhCLGdCQUFnQixjQURILE1BQU07MkZBQ25CLGdCQUFnQjtrQkFENUIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzYXZlQXMsIEZpbGVTYXZlck9wdGlvbnMgfSBmcm9tICdmaWxlLXNhdmVyJztcblxuLyoqIENoZWNrIHRoZSBgQmxvYmAgZXhpc3RhbmNlIG9ubHkgb25jZS4gKi9cbmxldCBpc0ZpbGVTYXZlclN1cHBvcnRlZDogYm9vbGVhbjtcbnRyeSB7XG4gIGlzRmlsZVNhdmVyU3VwcG9ydGVkID0gISFuZXcgQmxvYigpO1xufSBjYXRjaCB7XG4gIGlzRmlsZVNhdmVyU3VwcG9ydGVkID0gZmFsc2U7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRmlsZVNhdmVyU2VydmljZSB7XG4gIGdldCBpc0ZpbGVTYXZlclN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNGaWxlU2F2ZXJTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZW5UeXBlKGZpbGVOYW1lPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIWZpbGVOYW1lIHx8IGZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZmlsZU5hbWUuc3Vic3RyaW5nKGZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3R4dCc6XG4gICAgICAgIHJldHVybiAndGV4dC9wbGFpbic7XG4gICAgICBjYXNlICd4bWwnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiBgdGV4dC8ke3R5cGV9YDtcbiAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICByZXR1cm4gJ29jdGV0L3N0cmVhbSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uLyR7dHlwZX1gO1xuICAgIH1cbiAgfVxuXG4gIHNhdmUoYmxvYjogQmxvYiB8IG51bGwsIGZpbGVOYW1lPzogc3RyaW5nLCBmaWx0VHlwZT86IHN0cmluZywgb3B0aW9uPzogRmlsZVNhdmVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICghYmxvYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGFyZ3VtZW50IHNob3VsZCBiZSBhIGJsb2IgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoW2Jsb2JdLCB7IHR5cGU6IGZpbHRUeXBlIHx8IGJsb2IudHlwZSB8fCB0aGlzLmdlblR5cGUoZmlsZU5hbWUpIH0pO1xuICAgIHNhdmVBcyhmaWxlLCBkZWNvZGVVUkkoZmlsZU5hbWUgfHwgJ2Rvd25sb2FkJyksIG9wdGlvbik7XG4gIH1cblxuICBzYXZlVGV4dCh0eHQ6IHN0cmluZywgZmlsZU5hbWU/OiBzdHJpbmcsIG9wdGlvbj86IEZpbGVTYXZlck9wdGlvbnMpOiB2b2lkIHtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3R4dF0pO1xuICAgIHRoaXMuc2F2ZShibG9iLCBmaWxlTmFtZSwgdW5kZWZpbmVkLCBvcHRpb24pO1xuICB9XG59XG4iXX0=